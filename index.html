<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="copyright" content="FitOverlays - Copyright (c) 2025 Spyros Lontos">
    <meta name="license" content="AGPL-3.0">
    <title>Strava Overlay Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        strava: {
                            orange: '#fc4c02',
                            'dark-orange': '#e64c02',
                            background: '#f5f5f5',
                            text: '#2c3e50',
                            gray: '#a0a0a0'
                        }
                    }
                }
            }
        }
    </script>
</head>
<body class="bg-strava-background min-h-screen">
    <!-- Main Container -->
    <div class="max-w-3xl mx-auto space-y-1">
        <!-- Header Card -->
        <div class="bg-white rounded-xl shadow-lg py-1 px-4">
            <div class="relative min-h-[4rem] flex justify-between items-center">
                <div class="flex-1 min-w-0 pr-4">
                    <h1 class="font-bold">
                        <span class="text-2xl md:text-3xl lg:text-4xl text-strava-orange">FitOverlays</span>
                        <span class="text-xl md:text-xl lg:text-2xl text-strava-text block">a Strava Overlay Generator</span>
                    </h1>
                </div>
                <div class="auth-status flex-shrink-0">
                    <button id="auth-button" class="auth-button transition transform hover:scale-110 h-full">
                        <img src="static/images/btn_strava_connect_with_orange.svg" 
                             alt="Connect with Strava" 
                             id="auth-button-img"
                             class="h-full w-auto">
                    </button>
                    <button id="profile-dropdown-trigger" 
                            class="hidden absolute -bottom-0 -right-1 bg-white/80 rounded-full p-0 shadow-md border border-gray-200 hover:bg-gray-50">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-600" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M5.293 7.293a1 1 011.414 0L10 10.586l3.293-3.293a1 1 111.414 1.414l-4 4a1 1 01-1.414 0l-4-4a1 1 010-1.414z" clip-rule="evenodd" />
                        </svg>
                    </button>
                    <div id="profile-dropdown" class="hidden absolute right-0 mt-2 w-48 bg-white shadow-lg rounded-lg">
                        <button class="w-full text-left px-4 py-2 text-sm font-bold text-red-600 bg-gray-100 hover:bg-gray-200 rounded-lg" id="logout-button">
                            Log out
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Input Card -->
        <div class="bg-white rounded-xl shadow-lg p-6 space-y-1">
            <div class="space-y-2">
                <div class="flex items-center gap-2">
                    <div class="flex-1 relative">
                        <input type="text" 
                               id="activityInput" 
                               placeholder="Enter Strava Activity URL or ID" 
                               class="w-full px-4 py-3 rounded-lg border-2 border-strava-orange focus:outline-none focus:ring-2 focus:ring-strava-orange focus:border-transparent pr-10">
                        <button id="clearInput" 
                                class="absolute right-3 top-1/2 -translate-y-1/2 hidden">
                            <div class="bg-gray-300 hover:bg-gray-400 rounded-full p-1.5">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3 text-gray-600" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M4.293 4.293a1 1 011.414 0L10 8.586l4.293-4.293a1 1 111.414 1.414L11.414 10l4.293 4.293a1 1 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 01-1.414-1.414L8.586 10 4.293 5.707a1 1 010-1.414z" clip-rule="evenodd" />
                                </svg>
                            </div>
                        </button>
                    </div>
                    <button id="loadActivityBtn" 
                            class="bg-strava-orange hover:bg-strava-dark-orange text-white px-6 py-3 rounded-lg font-medium transition-colors whitespace-nowrap">
                        Load
                    </button>
                </div>
                <div id="statusMessage" 
                     class="transform translate-y-2 opacity-0 hidden rounded-lg p-4 text-sm transition-all duration-300 ease-in-out">
                </div>
                <div id="stravaLinkContainer" class="hidden text-center">
                    <a href="#" 
                       target="_blank" 
                       id="stravaLink" 
                       class="text-strava-orange hover:underline text-sm font-medium">
                        View Activity on Strava
                    </a>
                </div>
            </div>
        </div>

        <!-- Canvas Card -->
        <div class="bg-white rounded-xl shadow-lg p-6">
            <div class="relative aspect-square w-full">
                <canvas id="overlayCanvas" class="absolute inset-0 w-full h-full border-2 border-dashed border-strava-orange rounded-lg"></canvas>
            </div>
        </div>

        <!-- Options Card -->
        <div class="bg-white rounded-xl shadow-lg p-6 space-y-4">
            <h2 class="text-lg font-medium text-strava-text">Overlay Options</h2>
            <div id="overlayOptions" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-5 gap-2">
                <button class="overlay-option p-3 rounded-lg text-white bg-strava-gray transition-colors" data-metric="distance">
                    Distance
                </button>
                <button class="overlay-option p-3 rounded-lg text-white bg-strava-gray transition-colors" data-metric="pace">
                    Pace
                </button>
                <button class="overlay-option p-3 rounded-lg text-white bg-strava-gray transition-colors" data-metric="elevation">
                    Elevation
                </button>
                <button class="overlay-option p-3 rounded-lg text-white bg-strava-gray transition-colors" data-metric="time">
                    Time
                </button>
                <button class="overlay-option p-3 rounded-lg text-white bg-strava-gray transition-colors" data-metric="heartRate">
                    Heart Rate
                </button>
            </div>

            <div class="flex items-center gap-4">
                <label for="colorWheel" class="text-sm font-medium text-strava-text">Text Color</label>
                <input type="color" 
                       id="colorWheel" 
                       value="#ffffff" 
                       class="h-10 w-10 rounded-lg border-2 border-strava-orange cursor-pointer">
            </div>

            <div class="flex flex-col sm:flex-row gap-2">
                <button id="exportTextBtn" 
                        class="flex-1 bg-strava-text hover:bg-opacity-90 text-white px-6 py-3 rounded-lg font-medium transition-colors">
                    Export Text
                </button>
                <button id="copyImageBtn" 
                        class="flex-1 bg-strava-text hover:bg-opacity-90 text-white px-6 py-3 rounded-lg font-medium transition-colors">
                    Copy Image
                </button>
            </div>
        </div>

        <!-- Footer -->
        <div class="bg-white rounded-xl shadow-lg p-4 flex flex-col sm:flex-row justify-between items-center gap-2 text-sm text-strava-gray">
            <div>
                &copy; 2025 FitOverlays - Licensed under 
                <a href="https://www.gnu.org/licenses/agpl-3.0.html" 
                   target="_blank" 
                   class="hover:text-strava-orange transition-colors">
                    AGPL-3.0
                </a>
            </div>
            <img src="static/images/api_logo_pwrdBy_strava_horiz_black.svg" 
                 alt="Powered by Strava" 
                 class="h-4">
        </div>
    </div>

    <!-- Toast -->
    <div id="toast" class="fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-strava-orange text-white px-6 py-3 rounded-lg font-medium opacity-0 transition-opacity duration-300 pointer-events-none">
        Copied to clipboard!
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Add CSRF token management
            let csrfToken = '';

            // Update checkAuth function to store CSRF token
            async function checkAuth() {
                try {
                    const response = await fetch("/status", {
                        credentials: "include"
                    });
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();
                    csrfToken = data.csrf_token;  // Store CSRF token
                    
                    // Handle require_login flag
                    if (data.require_login) {
                        window.location.href = "/login";
                        return;
                    }

                    const button = document.getElementById('auth-button');
                    const buttonImg = document.getElementById('auth-button-img');
                    
                    if (data.authenticated) {
                        if (data.athlete_profile) {
                            buttonImg.src = data.athlete_profile;
                            buttonImg.alt = 'Profile Picture';
                            buttonImg.classList.remove('connect-btn');
                            buttonImg.classList.add('rounded-full', 'object-cover', 'w-12', 'h-12', 'border-2', 'border-green-500'); // Add green border
                            // Show dropdown trigger when logged in with profile
                            document.getElementById('profile-dropdown-trigger').classList.remove('hidden');
                        } else {
                            // Hide the button if no profile picture
                            button.style.display = 'none';
                        }
                        button.classList.remove('logged-out');
                        button.classList.add('logged-in');
                        state.isAuthenticated = true;
                        state.athleteId = data.athlete_id;  // Store athlete_id in state
                        enableActivityInput();

                        // Start token expiry check timer
                        if (data.expires_at) {
                            const timeToExpiry = data.expires_at - (Date.now() / 1000);
                            if (timeToExpiry > 0) {
                                // Check auth status 5 minutes before expiry
                                setTimeout(checkAuth, (timeToExpiry - 300) * 1000);
                            }
                        }
                    } else {
                        buttonImg.src = 'static/images/btn_strava_connect_with_orange.svg';
                        buttonImg.alt = 'Connect with Strava';
                        buttonImg.classList.add('connect-btn');
                        buttonImg.classList.remove('rounded-full', 'object-cover', 'w-12', 'h-12', 'border-2', 'border-green-500'); // Remove green border
                        button.classList.remove('logged-in');
                        button.classList.add('logged-out');
                        state.isAuthenticated = false;
                        disableActivityInput();
                        document.getElementById('profile-dropdown-trigger').classList.add('hidden');
                        document.getElementById('profile-dropdown').classList.add('hidden');

                        if (data.error) {
                            showStatusMessage(data.error);
                        }
                    }
                } catch (error) {
                    console.error("Auth check failed:", error);
                    const button = document.getElementById('auth-button');
                    const buttonImg = document.getElementById('auth-button-img');
                    buttonImg.src = 'static/images/btn_strava_connect_with_orange.svg';
                    buttonImg.alt = 'Connect with Strava';
                    buttonImg.classList.add('connect-btn');
                    buttonImg.classList.remove('rounded-full', 'object-cover', 'w-12', 'h-12', 'border-2', 'border-green-500'); // Remove green border
                    button.classList.remove('logged-in');
                    button.classList.add('logged-out');
                    state.isAuthenticated = false;
                    disableActivityInput();
                    showStatusMessage('Error checking authentication status'); // Add error message
                }
            }

            // Helper function to add CSRF token to fetch options
            function addCSRFToken(options = {}) {
                return {
                    ...options,
                    headers: {
                        ...options.headers,
                        'X-CSRF-Token': csrfToken
                    }
                };
            }

            // Update fetchActivityData function to include athlete_id
            async function fetchActivityData(activityId) {
                const athleteId = state.athleteId; // We'll get this from the status check
                if (!athleteId) {
                    throw new Error('No athlete ID available');
                }
                
                const fetchResponse = await fetch(
                    `/fetch_activity/${athleteId}/${activityId}`, 
                    addCSRFToken({
                        method: 'POST',  // Change to POST to trigger CSRF protection
                        credentials: "include"
                    })
                );
                
                if (!fetchResponse.ok) {
                    const error = new Error('Failed to fetch activity data');
                    error.status = fetchResponse.status;
                    const errorData = await fetchResponse.json();
                    
                    if (errorData.require_login) {
                        window.location.href = "/login";
                        return;
                    }
                    
                    error.message = errorData.error || error.message;
                    throw error;
                }
                
                return await fetchResponse.json();
            }

            // Update auth button click handler to include CSRF token for logout
            document.getElementById("auth-button").addEventListener("click", function() {
                if (this.classList.contains("logged-out")) {
                    window.location.href = "/login";
                } else {
                    fetch("/logout", addCSRFToken({
                        method: 'POST',  // Change to POST to trigger CSRF protection
                        credentials: "include"
                    })).then(() => {
                        window.location.href = "/";
                    });
                }
            });

            // Dropdown functionality
            const dropdownTrigger = document.getElementById('profile-dropdown-trigger');
            const dropdown = document.getElementById('profile-dropdown');
            const logoutButton = document.getElementById('logout-button');

            dropdownTrigger.addEventListener('click', (e) => {
                e.stopPropagation();
                dropdown.classList.toggle('hidden');
            });

            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (!dropdown.contains(e.target) && !dropdownTrigger.contains(e.target)) {
                    dropdown.classList.add('hidden');
                }
            });

            // Connect logout button to existing logout functionality
            logoutButton.addEventListener('click', () => {
                fetch("/logout", addCSRFToken({
                    method: 'POST',
                    credentials: "include"
                })).then(() => {
                    window.location.href = "/";
                });
            });

            // Check auth status on load
            checkAuth();

            // Existing code
            const activityInput = document.getElementById('activityInput');
            const loadActivityBtn = document.getElementById('loadActivityBtn');
            const overlayCanvas = document.getElementById('overlayCanvas');
            const colorWheel = document.getElementById('colorWheel');
            const exportTextBtn = document.getElementById('exportTextBtn');
            const copyImageBtn = document.getElementById('copyImageBtn');
            const ctx = overlayCanvas.getContext('2d');
            
            // Set fixed canvas dimensions for high quality
            overlayCanvas.width = 1500; // Square dimensions, high resolution
            overlayCanvas.height = 1500;

            // Enable image smoothing
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';

            // State management
            const state = {
                activityId: null,
                athleteId: null,  // Add athleteId to state
                selectedMetrics: [],
                textColor: '#ffffff',
                backgroundColor: '#2c3e50', // Default background color (accessible dark blue)
                template: 'minimal',
                isAuthenticated: false, // Add authentication state
            };
            
            // Message handling system
            const messageQueue = {
                timer: null,
                currentMessage: null,
                clear() {
                    if (this.timer) {
                        clearTimeout(this.timer);
                        this.timer = null;
                    }
                }
            };

            // Single implementation of message handling
            function showStatusMessage(message, type = 'error') {
                const statusMessage = document.getElementById('statusMessage');
                messageQueue.clear();
                
                const typeStyles = {
                    error: 'bg-red-100 text-red-700 border border-red-200',
                    success: 'bg-green-100 text-green-700 border border-green-200',
                    warning: 'bg-yellow-100 text-yellow-700 border border-yellow-200',
                    info: 'bg-blue-100 text-blue-700 border border-blue-200'
                };

                // Reset animation state
                statusMessage.classList.remove('hidden');
                statusMessage.classList.add('transform', 'translate-y-2', 'opacity-0');
                
                statusMessage.className = `transform translate-y-2 opacity-0 rounded-lg p-4 text-sm transition-all duration-300 ease-in-out ${typeStyles[type] || typeStyles.error}`;
                statusMessage.textContent = message;
                
                // Force a reflow
                void statusMessage.offsetWidth;
                
                // Slide up animation
                statusMessage.classList.remove('translate-y-2', 'opacity-0');
                statusMessage.classList.add('translate-y-0', 'opacity-100');
                
                messageQueue.timer = setTimeout(() => {
                    hideStatusMessage();
                }, 3000);
                
                messageQueue.currentMessage = message;
            }

            function hideStatusMessage() {
                messageQueue.clear();
                const statusMessage = document.getElementById('statusMessage');
                
                // If already hidden, do nothing
                if (statusMessage.classList.contains('hidden')) {
                    return;
                }
                
                // Slide down animation
                statusMessage.classList.remove('translate-y-0', 'opacity-100');
                statusMessage.classList.add('translate-y-2', 'opacity-0');
                
                // Wait for animation to complete before hiding
                setTimeout(() => {
                    statusMessage.classList.add('hidden');
                }, 300);
            }

            // Mock Strava API data (replace with actual API call)
            const mockStravaData = {
                distance: 10.5,
                pace: '5:30',
                elevation: 250,
                time: '01:02:15',
                heartRate: 162
            };

            // Set fixed canvas dimensions
            function initCanvas() {
                generateOverlay(mockStravaData);
            }

            // Replace resizeCanvas with initCanvas
            initCanvas();

            function extractActivityId(input) {
                // Remove any whitespace from input
                input = input.trim();
                
                // Deep link pattern - pass through for server-side resolution
                const deepLinkPattern = /^(?:https?:\/\/)?strava\.app\.link\/[A-Za-z0-9_-]+$/;
                if (deepLinkPattern.test(input)) {
                    return input; // Return the full deep link for server processing
                }
                
                // Pattern for full Strava URLs
                const urlPattern = /^(?:https?:\/\/)?(?:www\.)?strava\.com\/activities\/(\d+)(?:[?#].*)?$/i;
                const urlMatch = input.match(urlPattern);
                if (urlMatch) {
                    // Validate length of extracted ID
                    if (urlMatch[1].length >= 21) {
                        return null;
                    }
                    return urlMatch[1];
                }
                
                // Handle direct ID input - accept any number with length < 21
                const idPattern = /^\d+$/;
                if (idPattern.test(input) && input.length < 21) {
                    return input;
                }
                
                return null;
            }

            // Update load activity button click handler
            loadActivityBtn.addEventListener('click', async () => {
                if (!state.isAuthenticated) {
                    showLoginRequired('load activities');
                    return;
                }

                const input = activityInput.value.trim();
                const activityIdentifier = extractActivityId(input);
                
                if (!activityIdentifier) {
                    showStatusMessage('Please enter a valid Strava activity URL or ID. Example:  https://strava.app.link/ab12cd34ef or https://www.strava.com/activities/123456789 or 123456789', 'error');
                    return;
                }

                loadActivityBtn.disabled = true;

                try {
                    const activityData = await fetchActivityData(activityIdentifier);
                    state.activityId = activityData.id; // Use the resolved activity ID from server
                    
                    // Update mockStravaData with real data
                    mockStravaData.distance = (activityData.distance / 1000).toFixed(2);
                    mockStravaData.time = new Date(activityData.moving_time * 1000).toISOString().substr(11, 8);
                    mockStravaData.elevation = Math.round(activityData.total_elevation_gain);
                    mockStravaData.pace = ((activityData.moving_time / 60) / (activityData.distance / 1000)).toFixed(2);
                    mockStravaData.heartRate = activityData.average_heartrate ? Math.round(activityData.average_heartrate) : 0;

                    // Update Strava link
                    const linkContainer = document.getElementById('stravaLinkContainer');
                    const stravaLink = document.getElementById('stravaLink');
                    stravaLink.href = `https://www.strava.com/activities/${activityData.id}`;
                    linkContainer.classList.add('show');

                    generateOverlay(mockStravaData);
                    exportTextBtn.disabled = false;
                    copyImageBtn.disabled = false;
                    
                    showStatusMessage(`Activity "${activityData.name}" loaded successfully`, 'success');
                } catch (error) {
                    console.error('Error loading activity:', error);
                    if (error.status === 401) {
                        showStatusMessage('Please login to access activities', 'error');
                    } else if (error.status === 403) {
                        showStatusMessage('You do not have permission to access this activity', 'error');
                    } else if (error.status === 429) {
                        showStatusMessage('Too many requests. Please wait a minute before trying again.', 'error');
                    } else {
                        // Always show this generic message for other errors
                        showStatusMessage('Failed to load activity. Please check the activity ID and try again.', 'error');
                    }
                    // Hide Strava link on error
                    document.getElementById('stravaLinkContainer').classList.remove('show');
                } finally {
                    loadActivityBtn.disabled = false;
                }
            });

            // Update activityInput validation to be less strict
            activityInput.addEventListener('input', (e) => {
                const input = e.target.value.trim();
                if (input && !extractActivityId(input)) {
                    activityInput.classList.add('invalid');
                } else {
                    activityInput.classList.remove('invalid');
                }
            });

            // Add functions to enable/disable activity input
            function enableActivityInput() {
                activityInput.disabled = false;
                loadActivityBtn.disabled = false;
                activityInput.placeholder = "Enter Strava Activity URL or ID";
            }

            function disableActivityInput() {
                activityInput.disabled = true;
                // Don't disable load button to allow error message trigger
                loadActivityBtn.disabled = false;
                activityInput.placeholder = "Please login to load activities";
                // Clear any existing activity data
                state.activityId = null;
                generateOverlay(mockStravaData);
                // Don't show message immediately, wait for user interaction
                document.getElementById('stravaLinkContainer').classList.remove('show');
            }

            // Existing code
            document.querySelectorAll('.overlay-option').forEach(option => {
                option.addEventListener('click', () => {
                    if (!state.isAuthenticated) {
                        showStatusMessage('Please login to customize overlays', 'warning');
                        return;
                    }
                    if (!state.activityId) {
                        showStatusMessage('Please load an activity first to customize overlays', 'warning');
                        return;
                    }

                    option.classList.toggle('active');
                    const metric = option.dataset.metric;
                    
                    if (state.selectedMetrics.includes(metric)) {
                        state.selectedMetrics = state.selectedMetrics.filter(m => m !== metric);
                    } else {
                        state.selectedMetrics.push(metric);
                    }

                    if (state.activityId) {
                        generateOverlay(mockStravaData);
                    }
                });
            });

            // Update color wheel handler
            colorWheel.addEventListener('input', (e) => {
                if (!state.isAuthenticated) {
                    showStatusMessage('Please login to customize colors', 'warning');
                    return;
                }
                if (!state.activityId) {
                    showStatusMessage('Please load an activity first to customize colors', 'warning');
                    return;
                }

                state.textColor = e.target.value;
                generateOverlay(mockStravaData);
            });

            // Generate Overlay
            function generateOverlay(data) {
                // Clear the entire canvas
                ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

                // Draw background color
                ctx.fillStyle = state.backgroundColor;
                ctx.fillRect(0, 0, overlayCanvas.width, overlayCanvas.height);
                drawMetrics(data);
            }

            function drawMetrics(data, context = ctx) {
                // Calculate center position
                const centerX = overlayCanvas.width / 2;
                const centerY = overlayCanvas.height / 2;

                // Adjust font sizes for square canvas
                const metricsCount = Math.max(1, state.selectedMetrics.length);
                const titleFontSize = Math.min(80, 160 * (5 / metricsCount));
                const valueFontSize = Math.min(100, 200 * (5 / metricsCount));
                const spacing = Math.min(60, 120 * (5 / metricsCount));

                const metrics = [
                    { name: 'Distance', value: `${data.distance} km`, key: 'distance' },
                    { name: 'Pace', value: `${data.pace} min/km`, key: 'pace' },
                    { name: 'Elevation', value: `${data.elevation} m`, key: 'elevation' },
                    { name: 'Time', value: data.time, key: 'time' },
                    { name: 'Heart Rate', value: `${data.heartRate} bpm`, key: 'heartRate' }
                ];

                const selectedMetrics = metrics.filter(metric => 
                    state.selectedMetrics.includes(metric.key)
                );

                const totalHeight = selectedMetrics.length * (titleFontSize + valueFontSize + spacing);
                let yOffset = centerY - (totalHeight / 2);

                // Styling
                context.fillStyle = state.textColor;
                context.textAlign = 'center';
                context.textBaseline = 'top';

                selectedMetrics.forEach(metric => {
                    // Title
                    context.font = `bold ${titleFontSize}px Arial`;
                    context.fillText(metric.name, centerX, yOffset);
                    
                    // Value
                    context.font = `bold ${valueFontSize}px Arial`;
                    context.fillText(metric.value, centerX, yOffset + titleFontSize + 10);
                    
                    yOffset += titleFontSize + valueFontSize + spacing;
                });
            }

            function measureTextBounds(context, metrics, titleFontSize, valueFontSize, spacing) {
                let minX = overlayCanvas.width;
                let maxX = 0;
                let minY = overlayCanvas.height;
                let maxY = 0;
                
                metrics.forEach(metric => {
                    // Measure title
                    context.font = `bold ${titleFontSize}px Arial`;
                    const titleWidth = context.measureText(metric.name).width;
                    // Measure value
                    context.font = `bold ${valueFontSize}px Arial`;
                    const valueWidth = context.measureText(metric.value).width;
                    
                    const width = Math.max(titleWidth, valueWidth);
                    minX = Math.min(minX, (overlayCanvas.width - width) / 2);
                    maxX = Math.max(maxX, (overlayCanvas.width + width) / 2);
                });

                const totalHeight = metrics.length * (titleFontSize + valueFontSize + spacing);
                const startY = (overlayCanvas.height - totalHeight) / 2;
                minY = startY;
                maxY = startY + totalHeight;

                return { minX, maxX, minY, maxY };
            }

            function getCroppedDimensions(data, context) {
                const metricsCount = Math.max(1, state.selectedMetrics.length);
                const titleFontSize = Math.min(80, 160 * (5 / metricsCount));
                const valueFontSize = Math.min(100, 200 * (5 / metricsCount));
                const spacing = Math.min(60, 120 * (5 / metricsCount));

                const metrics = [
                    { name: 'Distance', value: `${data.distance} km`, key: 'distance' },
                    { name: 'Pace', value: `${data.pace} min/km`, key: 'pace' },
                    { name: 'Elevation', value: `${data.elevation} m`, key: 'elevation' },
                    { name: 'Time', value: data.time, key: 'time' },
                    { name: 'Heart Rate', value: `${data.heartRate} bpm`, key: 'heartRate' }
                ].filter(metric => state.selectedMetrics.includes(metric.key));

                const bounds = measureTextBounds(context, metrics, titleFontSize, valueFontSize, spacing);
                const margin = 40;

                return {
                    x: Math.max(0, bounds.minX - margin),
                    y: Math.max(0, bounds.minY - margin),
                    width: Math.min(overlayCanvas.width, bounds.maxX - bounds.minX + 2 * margin),
                    height: Math.min(overlayCanvas.height, bounds.maxY - bounds.minY + 2 * margin)
                };
            }

            function showToast() {
                const toast = document.getElementById('toast');
                toast.classList.add('show');
                setTimeout(() => {
                    toast.classList.remove('show');
                }, 2000);
            }

            function showActionRequired(action) {
                if (!state.isAuthenticated) {
                    showLoginRequired(action);
                    return true;
                }
                if (!state.activityId) {
                    showStatusMessage('Please load an activity first before exporting');
                    return true;
                }
                return false;
            }

            async function requestClipboardPermission(type) {
                // Only check permissions for image copying
                if (type === 'copy image') {
                    try {
                        const result = await navigator.permissions.query({ name: 'clipboard-write' });
                        if (result.state === 'denied') {
                            showStatusMessage('Please allow clipboard access in your browser settings to copy images');
                            return false;
                        }
                    } catch (err) {
                        // If permissions API isn't supported, proceed anyway
                        return true;
                    }
                }
                // Always allow text copying
                return true;
            }

            // Update export text button handler
            exportTextBtn.addEventListener('click', async () => {
                if (showActionRequired('export activities')) return;

                // Remove permission check for text
                const metrics = [
                    { name: 'Distance', value: `${mockStravaData.distance} km`, key: 'distance' },
                    { name: 'Pace', value: `${mockStravaData.pace} min/km`, key: 'pace' },
                    { name: 'Elevation', value: `${mockStravaData.elevation} m`, key: 'elevation' },
                    { name: 'Time', value: `${mockStravaData.time}`, key: 'time' },
                    { name: 'Heart Rate', value: `${mockStravaData.heartRate} bpm`, key: 'heartRate' }
                ];

                const exportText = metrics
                    .filter(metric => state.selectedMetrics.includes(metric.key))
                    .map(metric => `${metric.name}\n${metric.value}`)
                    .join('\n\n');

                try {
                    await navigator.clipboard.writeText(exportText);
                    showToast();
                } catch (err) {
                    // iOS fallback with explicit user action required
                    const textarea = document.createElement('textarea');
                    textarea.value = exportText;
                    textarea.style.position = 'fixed';
                    textarea.style.opacity = '0';
                    document.body.appendChild(textarea);
                    textarea.select();
                    
                    try {
                        document.execCommand('copy');
                        showToast();
                    } catch (err) {
                        showStatusMessage('Unable to copy text to clipboard');
                    }

                    document.body.removeChild(textarea);
                }
            });

            copyImageBtn.addEventListener('click', async () => {
                if (showActionRequired('export activities')) return;

                // if (!await requestClipboardPermission('copy image')) {
                //     return;
                // }

                const dimensions = getCroppedDimensions(mockStravaData, ctx);

                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = dimensions.width;
                tempCanvas.height = dimensions.height;
                const tempCtx = tempCanvas.getContext('2d');

                tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
                tempCtx.save();
                tempCtx.translate(-dimensions.x, -dimensions.y);
                drawMetrics(mockStravaData, tempCtx);
                tempCtx.restore();

                try {
                    const blob = await new Promise(resolve => tempCanvas.toBlob(resolve, 'image/png'));

                    // Check for ClipboardItem support
                    if (window.ClipboardItem) {
                        try {
                            const item = new ClipboardItem({ 'image/png': blob });
                            await navigator.clipboard.write([item]);
                            showToast();
                        } catch (err) {
                            console.error('Clipboard write (ClipboardItem) failed:', err);
                            fallbackDownload(blob);
                        }
                    } else {
                        // ClipboardItem not supported, use fallback
                        console.log('Falling back to download');
                        fallbackDownload(blob);
                    }

                } catch (err) {
                    console.error('Unable to process image:', err);
                    showStatusMessage('Unable to process image');
                }
            });

            function fallbackDownload(blob) {
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.download = 'strava-overlay.png';
                link.href = url;
                link.click();
                URL.revokeObjectURL(url);
                showStatusMessage('Image downloaded (clipboard access not fully supported)');
            }

            // Update validation in activity input handler
            activityInput.addEventListener('input', (e) => {
                const input = e.target.value.trim();
                if (input) {
                    // Simple client-side validation for immediate feedback
                    const directPattern = /^(?:https?:\/\/)?(?:www\.)?strava\.com\/activities\/\d+(?:\/.*)?$/;
                    const deepLinkPattern = /^(?:https?:\/\/)?strava\.app\.link\/[A-Za-z0-9_-]+$/;
                    const idPattern = /^\d+$/;
                    
                    if (!directPattern.test(input) && !deepLinkPattern.test(input) && !idPattern.test(input)) {
                        activityInput.classList.add('invalid');
                    } else {
                        activityInput.classList.remove('invalid');
                        hideStatusMessage(); // Add this line
                    }
                } else {
                    activityInput.classList.remove('invalid');
                    hideStatusMessage(); // Add this line
                }
            });

            activityInput.addEventListener('input', (e) => {
                const clearButton = document.getElementById('clearInput');
                if (e.target.value) {
                    clearButton.classList.remove('hidden');
                } else {
                    clearButton.classList.add('hidden');
                }
            });

            document.getElementById('clearInput').addEventListener('click', () => {
                activityInput.value = '';
                activityInput.classList.remove('invalid');
                document.getElementById('clearInput').classList.add('hidden');
                hideStatusMessage(); // Add this line
            });

            // Update the showLoginRequired function
            function showLoginRequired(action) {
                const statusMessage = document.getElementById('statusMessage');
                messageQueue.clear();
                
                const message = `Please login to ${action}`;
                const typeStyles = 'bg-yellow-100 text-yellow-700 border border-yellow-200';
                
                statusMessage.className = `transform translate-y-2 opacity-0 rounded-lg p-4 text-sm transition-all duration-300 ease-in-out ${typeStyles}`;
                statusMessage.textContent = message;
                statusMessage.classList.remove('hidden');
                
                void statusMessage.offsetWidth;
                
                statusMessage.classList.remove('translate-y-2', 'opacity-0');
                statusMessage.classList.add('translate-y-0', 'opacity-100');
                
                messageQueue.timer = setTimeout(() => {
                    hideStatusMessage();
                }, 3000);
                
                messageQueue.currentMessage = message;
            }

            // Update activityInput input handler to use hideStatusMessage
            activityInput.addEventListener('input', (e) => {
                const input = e.target.value.trim();
                if (input) {
                    // Simple client-side validation for immediate feedback
                    const directPattern = /^(?:https?:\/\/)?(?:www\.)?strava\.com\/activities\/\d+(?:\/.*)?$/;
                    const deepLinkPattern = /^(?:https?:\/\/)?strava\.app\.link\/[A-Za-z0-9_-]+$/;
                    const idPattern = /^\d+$/;
                    
                    if (!directPattern.test(input) && !deepLinkPattern.test(input) && !idPattern.test(input)) {
                        activityInput.classList.add('invalid');
                    } else {
                        activityInput.classList.remove('invalid');
                        if (messageQueue.currentMessage) {
                            hideStatusMessage();
                        }
                    }
                } else {
                    activityInput.classList.remove('invalid');
                    if (messageQueue.currentMessage) {
                        hideStatusMessage();
                    }
                }
            });

            // Update overlay-option click handler 
            document.querySelectorAll('.overlay-option').forEach(option => {
                option.addEventListener('click', () => {
                    if (!state.isAuthenticated) {
                        showStatusMessage('Please login to customize overlays', 'warning');
                        return;
                    }
                    if (!state.activityId) {
                        showStatusMessage('Please load an activity first to customize overlays', 'warning');
                        return;
                    }
                    // ...rest of overlay option code...
                });
            });

            // Update color wheel handler
            colorWheel.addEventListener('input', (e) => {
                if (!state.isAuthenticated) {
                    showStatusMessage('Please login to customize colors', 'warning');
                    return;
                }
                if (!state.activityId) {
                    showStatusMessage('Please load an activity first to customize colors', 'warning');
                    return;
                }
                // ...rest of color wheel code...
            });

        });
    </script>
</body>
</html>