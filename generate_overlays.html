<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/x-icon" href="/static/images/favicon.ico">
    <meta name="copyright" content="FitOverlays - Copyright (c) 2025 Spyros Lontos">
    <meta name="license" content="AGPL-3.0">
    <title>Strava Overlay Generator</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Roboto', 'sans-serif'],
                    },
                    colors: {
                        'strava-orange': '#fc4c02',
                        'strava-dark-orange': '#e34402',
                        'strava-gray': '#666666',
                        'strava-text': '#242428',
                    },
                },
            },
        }
    </script>
    <style> 
        html {
            scroll-behavior: smooth;
        }
        
        .checkerboard {
            background-image:
                linear-gradient(45deg, #f0f0f0 25%, transparent 25%),
                linear-gradient(-45deg, #f0f0f0 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #f0f0f0 75%),
                linear-gradient(-45deg, transparent 75%, #f0f0f0 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            background-color: #ffffff;
            position: relative;
        }
        
        /* Add a semi-transparent overlay to improve contrast with any text color */
        .checkerboard::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.05);
            border-radius: inherit;
        }

        .aspect-9-16 {
            aspect-ratio: 9/16;
            width: 100%;
            max-height: 50vh; /* Reduced from 60vh */
            max-width: calc(50vh * 9/16); /* Adjusted to match new max-height */
            margin: 0 auto;
        }

        /* Add dark checkerboard pattern */
        canvas.dark-checkerboard {
            background-image:
                linear-gradient(45deg, #1a1a1a 25%, transparent 25%),
                linear-gradient(-45deg, #1a1a1a 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #1a1a1a 75%),
                linear-gradient(-45deg, transparent 75%, #1a1a1a 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            background-color: #2c2c2c;
        }

        /* Style the color picker */
        input[type="color"] {
            -webkit-appearance: none;
            appearance: none;
            background: none;
            border: none;
            cursor: pointer;
            padding: 0;
            width: 48px;
            height: 48px;
        }

        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        input[type="color"]::-webkit-color-swatch {
            border: 2px solid #fc4c02;
            border-radius: 8px;
            padding: 0;
        }

        /* Firefox */
        input[type="color"]::-moz-color-swatch {
            border: 2px solid #fc4c02;
            border-radius: 8px;
            padding: 0;
        }

        /* Update text alignment button styles - replace all previous .text-align-btn styles */
        .text-align-btn {
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid #fc4c02;
            background-color: white;
            color: #666666;
            border-radius: 0.5rem;
            transition: all 0.2s;
        }

        .text-align-btn:hover {
            background-color: #f3f4f6;
        }

        .text-align-btn.active {
            background-color: #fc4c02;
            color: white;
        }

        .text-align-btn svg {
            width: 24px;
            height: 24px;
        }
    </style>
</head>
<body class="font-sans antialiased text-gray-800 bg-gradient-to-br from-white to-[#fc4c02]/40">
    
    <header class="bg-white/80 backdrop-blur-sm shadow-md sticky top-0 z-50 border-b border-gray-200/50">
        <nav class="container mx-auto px-4 py-3 grid grid-cols-3 items-center max-w-[900px]">
            <div class="flex justify-start min-w-[40px]">
                <div id="profile-container" class="hidden">
                    <img id="profile-picture" 
                         src="" 
                         alt="Profile" 
                         class="w-8 h-8 rounded-full object-cover border border-gray-200/50">
                </div>
            </div>

            <div class="text-center flex justify-center items-center">
                <a href="/" class="text-3xl font-bold hover:opacity-80 transition-opacity">
                    <span class="text-[#fc4c02]">Fitness</span><span class="text-gray-900">Overlays</span>
                </a>
            </div>

            <div class="flex justify-end min-w-[40px]">
                <a href="/input_activity" id="create-overlay-header-btn" 
                   class="hidden w-8 h-8 bg-[#fc4c02] text-white rounded-full 
                          flex items-center justify-center
                          transform hover:scale-110 transition-all duration-200 
                          drop-shadow-lg">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z" clip-rule="evenodd" />
                    </svg>
                </a>
            </div>
        </nav>
    </header>

    <main class="flex-grow container mx-auto p-3">
        <div class="max-w-[900px] w-full mx-auto">
            <!-- Activity Info Card -->
            <div id="activityInfoCard" class="bg-white rounded-xl shadow-lg p-3 mb-3">
                <div class="flex justify-between items-center">
                    <h2 id="activityName" class="text-lg text-gray-800"></h2>
                    <a id="stravaLink" href="#" target="_blank" 
                       class="bg-strava-orange hover:bg-strava-dark-orange text-white p-3 rounded-lg text-sm font-medium transition-colors">
                        View on Strava
                    </a>
                </div>
            </div>

            <!-- Canvas Card -->
            <div class="bg-white rounded-xl relative shadow-lg p-3 max-w-sm mx-auto mb-3">
                <div class="aspect-9-16 relative w-full max-w-sm">
                    <div class="checkerboard absolute inset-0 rounded-lg border-2 border-dashed border-strava-orange"></div>
                    <canvas id="overlayCanvas" class="absolute inset-0 w-full h-full"></canvas>
                </div>
            </div>

            <!-- Options Card -->
            <div class="bg-white rounded-xl shadow-lg p-6 space-y-4">
                <!-- Section Headers -->
                <div class="flex space-x-2">
                    <button class="section-header flex-1 p-3 bg-gray-100 hover:bg-gray-200 rounded-lg transition-colors" data-section="text">
                        <span class="font-medium text-strava-text">Text Overlay</span>
                    </button>
                    <button class="section-header flex-1 p-3 bg-gray-100 hover:bg-gray-200 rounded-lg transition-colors" data-section="maps">
                        <span class="font-medium text-strava-text">Map Styles</span>
                    </button>
                    <button class="section-header flex-1 p-3 bg-gray-100 hover:bg-gray-200 rounded-lg transition-colors" data-section="graphs">
                        <span class="font-medium text-strava-text">Activity Graphs</span>
                    </button>
                </div>

                <!-- Section Contents -->
                <div id="textSection" class="section-content">
                    <div id="overlayOptions" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-2">
                        <button class="overlay-option p-3 rounded-lg text-white bg-strava-gray transition-colors" data-metric="distance">Distance</button>
                        <button class="overlay-option p-3 rounded-lg text-white bg-strava-gray transition-colors" data-metric="movingTime">Time</button>
                        <button class="overlay-option p-3 rounded-lg text-white bg-strava-gray transition-colors" data-metric="pace">Pace</button>
                        <button class="overlay-option p-3 rounded-lg text-white bg-strava-gray transition-colors" data-metric="elevationGain">Elevation</button>
                        <button class="overlay-option p-3 rounded-lg text-white bg-strava-gray transition-colors" data-metric="avgHeartRate">Avg HR</button>
                        <button class="overlay-option p-3 rounded-lg text-white bg-strava-gray transition-colors" data-metric="maxHeartRate">Max HR</button>
                        <button class="overlay-option p-3 rounded-lg text-white bg-strava-gray transition-colors" data-metric="calories">Calories</button>
                        <button class="overlay-option p-3 rounded-lg text-white bg-strava-gray transition-colors" data-metric="sufferScore">Suffer Score</button>
                    </div>

                    <!-- Update text controls container -->
                    <div class="flex items-center gap-4 mt-4">
                        <!-- Color Picker -->
                        <label for="colorWheel" class="text-sm font-medium text-strava-text">Text Color</label>
                        <div class="relative group">
                            <input type="color" id="colorWheel" value="#ffffff" 
                                class="transition-transform hover:scale-105 focus:scale-105"
                                title="Choose text color">
                        </div>

                        <!-- Text Alignment with updated container -->
                        <div class="flex gap-1 ml-4">
                            <button class="text-align-btn" data-align="left" title="Align Left">
                                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 10h10M4 14h16M4 18h10" />
                                </svg>
                            </button>
                            <button class="text-align-btn active" data-align="center" title="Center">
                                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M7 10h10M4 14h16M7 18h10" />
                                </svg>
                            </button>
                            <button class="text-align-btn" data-align="right" title="Align Right">
                                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M10 10h10M4 14h16M10 18h10" />
                                </svg>
                            </button>
                        </div>
                    </div>
                </div>

                <div id="mapsSection" class="section-content hidden">
                    <div class="grid grid-cols-2 sm:grid-cols-3 gap-2">
                        <button class="map-option p-3 rounded-lg text-white bg-strava-gray transition-colors" data-style="light">Light</button>
                        <button class="map-option p-3 rounded-lg text-white bg-strava-gray transition-colors" data-style="dark">Dark</button>
                        <button class="map-option p-3 rounded-lg text-white bg-strava-gray transition-colors" data-style="outdoors">Outdoors</button>
                        <button class="map-option p-3 rounded-lg text-white bg-strava-gray transition-colors" data-style="satellite">Satellite</button>
                        <button class="map-option p-3 rounded-lg text-white bg-strava-gray transition-colors" data-style="minimal">Minimal</button>
                    </div>
                </div>

                <div id="graphsSection" class="section-content hidden">
                    <div class="grid grid-cols-2 gap-2">
                        <button class="graph-option p-3 rounded-lg text-white bg-strava-gray transition-colors" data-graph="pace">Pace Graph</button>
                        <button class="graph-option p-3 rounded-lg text-white bg-strava-gray transition-colors" data-graph="heartrate">Heart Rate Graph</button>
                    </div>
                </div>

                <!-- Copy Buttons -->
                <div class="flex flex-col sm:flex-row gap-2 mt-6">
                    <div class="flex-1 flex flex-col items-center gap-1">
                        <button id="copyTextBtn" 
                                class="w-14 h-14 bg-strava-text hover:bg-opacity-90 text-white rounded-xl font-medium transition-colors flex items-center justify-center">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M8.25 7.5V6.108c0-1.135.845-2.098 1.976-2.192.373-.03.748-.057 1.123-.08M15.75 18H18a2.25 2.25 0 0 0 2.25-2.25V6.108c0-1.135-.845-2.098-1.976-2.192a48.424 48.424 0 0 0-1.123-.08M15.75 18.75v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5A3.375 3.375 0 0 0 6.375 7.5H5.25m11.9-3.664A2.251 2.251 0 0 0 15 2.25h-1.5a2.251 2.251 0 0 0-2.15 1.586m5.8 0c.065.21.1.433.1.664v.75h-6V4.5c0-.231.035-.454.1-.664M6.75 7.5H4.875c-.621 0-1.125.504-1.125 1.125v12c0 .621.504 1.125 1.125 1.125h9.75c.621 0 1.125-.504 1.125-1.125V16.5a9 9 0 0 0-9-9Z" />
                            </svg>
                        </button>
                        <span class="text-sm text-strava-text">Copy to Clipboard as text</span>
                    </div>
                    <div class="flex-1 flex flex-col items-center gap-1">
                        <button id="copyImageBtn" 
                                class="w-14 h-14 bg-strava-text hover:bg-opacity-90 text-white rounded-xl font-medium transition-colors flex items-center justify-center">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M11.35 3.836c-.065.21-.1.433-.1.664 0 .414.336.75.75.75h4.5a.75.75 0 0 0 .75-.75 2.25 2.25 0 0 0-.1-.664m-5.8 0A2.251 2.251 0 0 1 13.5 2.25H15c1.012 0 1.867.668 2.15 1.586m-5.8 0c-.376.023-.75.05-1.124.08C9.095 4.01 8.25 4.973 8.25 6.108V8.25m8.9-4.414c.376.023.75.05 1.124.08 1.131.094 1.976 1.057 1.976 2.192V16.5A2.25 2.25 0 0 1 18 18.75h-2.25m-7.5-10.5H4.875c-.621 0-1.125.504-1.125 1.125v11.25c0 .621.504 1.125 1.125 1.125h9.75c.621 0 1.125-.504 1.125-1.125V18.75m-7.5-10.5h6.375c.621 0 1.125.504 1.125 1.125v9.375m-8.25-3 1.5 1.5 3-3.75" />
                            </svg>
                        </button>
                        <span class="text-sm text-strava-text">Copy to Clipboard as Image</span>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <footer class="bg-gray-900/80 backdrop-blur-sm text-gray-300 text-sm py-6 border-t border-gray-700/50">
        <div class="container mx-auto px-4 flex flex-col items-center space-y-4">
            <div class="text-center">
                &copy; 2025 FitnessOverlays - Licensed under <a href="https://www.gnu.org/licenses/agpl-3.0.html" 
                   target="_blank" 
                   class="hover:text-strava-orange transition-colors">
                    AGPL-3.0
                </a>
            </div>
            <div>
                <img src="/static/images/api_logo_pwrdBy_strava_horiz_white.svg" 
                     alt="Powered by Strava" 
                     class="h-4 width-auto mx-auto">
            </div>
        </div>
    </footer>

    <!-- Toast -->
    <div id="toast" class="fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-strava-orange text-white px-6 py-3 rounded-lg font-medium transition-all duration-300 pointer-events-none z-50 opacity-0">
        Copied to clipboard!
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Add CSRF token management
            let csrfToken = '';
            // Unused: let previousPage = document.referrer;

            const state = {
                activityId: null,
                activityData: null,
                athleteId: null,
                selectedMetrics: ['distance', 'movingTime', 'pace'],
                isAuthenticated: false,
                textColor: '#ffffff',
                textAlign: 'center', // Default center alignment
            };

            const StravaData = {};

            const activityInfoCard = document.getElementById('activityInfoCard');
            const activityName = document.getElementById('activityName');
            const stravaLink = document.getElementById('stravaLink');

            // Helper function to add CSRF token to fetch options
            function addCSRFToken(options = {}) {
                return {
                    ...options,
                    headers: {
                        ...options.headers,
                        'X-CSRF-Token': csrfToken
                    }
                };
            }

            // Update checkAuth function to store CSRF token
            async function checkAuth() {
                try {
                    const response = await fetch("/status", {
                        credentials: "include"
                    });
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();
                    csrfToken = data.csrf_token;  // Store CSRF token
                    
                    // Handle require_login flag
                    if (data.require_login) {
                        window.location.href = "/login";
                        return;
                    }
                    
                    if (data.authenticated) {
                        console.log('User is authenticated:', data);  // Log authentication status
                        // Show profile picture if available
                        if (data.athlete_profile) {
                            const profileContainer = document.getElementById('profile-container');
                            const profilePicture = document.getElementById('profile-picture');
                            profilePicture.src = data.athlete_profile;
                            profileContainer.classList.remove('hidden');
                        }
                        state.isAuthenticated = true;
                        state.athleteId = data.athlete_id;  // Store athlete_id in state
                        document.getElementById('create-overlay-header-btn').classList.remove('hidden');

                        // Now that auth is confirmed, check for activity data
                        loadActivityFromSession();

                        // Start token expiry check timer
                        if (data.expires_at) {
                            const timeToExpiry = data.expires_at - (Date.now() / 1000);
                            if (timeToExpiry > 0) {
                                // Check auth status 5 minutes before expiry
                                setTimeout(checkAuth, (timeToExpiry - 300) * 1000);
                            }
                        }
                    } else {
                        console.log('User is not authenticated:', data);  // Log authentication status
                        // Hide profile picture and create buttons when not authenticated
                        document.getElementById('profile-container').classList.add('hidden');
                        document.getElementById('create-overlay-header-btn').classList.add('hidden');
                    }
                } catch (error) {
                    console.error("Auth check failed:", error);
                }
            }

            // Check auth status first - this will trigger loadActivityFromSession if successful
            checkAuth();

            // Function to load and process activity data from sessionStorage
            function loadActivityFromSession() {
                const storedActivity = sessionStorage.getItem('currentActivity');
                // console.log("Checking sessionStorage for 'currentActivity' on page load:", storedActivity);

                if (!storedActivity) {
                    console.warn('No activity data found in session storage. Canvas will be empty.');
                    return;
                }

                try {
                    const parsedData = JSON.parse(storedActivity);
                    console.log("Successfully parsed activity data:", parsedData);
                    state.activityData = parsedData; // Store parsed data in state
                    state.activityId = parsedData.id;

                    // Display Activity Info Card
                    activityName.textContent = parsedData.name || 'Untitled Activity';
                    stravaLink.href = `https://www.strava.com/activities/${parsedData.id}`;

                    // Create metrics map with availability status
                    const metricsAvailability = {
                        distance: !!parsedData.distance,
                        movingTime: !!parsedData.moving_time,
                        pace: !!(parsedData.moving_time && parsedData.distance),
                        elevationGain: !!parsedData.total_elevation_gain,
                        avgHeartRate: !!parsedData.average_heartrate,
                        maxHeartRate: !!parsedData.max_heartrate,
                        calories: !!parsedData.calories,
                        sufferScore: !!parsedData.suffer_score
                    };

                    console.log("metricsAvailability:", metricsAvailability);

                    // Update buttons based on data availability
                    document.querySelectorAll('.overlay-option').forEach(button => {
                        const metric = button.dataset.metric;
                        if (!metricsAvailability[metric]) {
                            button.disabled = true;
                            button.classList.remove('bg-strava-gray', 'bg-strava-orange');
                            button.classList.add('bg-gray-300', 'cursor-not-allowed');
                        } else {
                            button.disabled = false;
                            button.classList.remove('bg-gray-300', 'cursor-not-allowed');
                            button.classList.add('bg-strava-gray');
                        }
                    });

                    // Update StravaData only for available metrics
                    StravaData.distance = metricsAvailability.distance ? (parsedData.distance / 1000).toFixed(2) + ' km' : null;
                    StravaData.movingTime = metricsAvailability.movingTime ? formatDuration(parsedData.moving_time) : null;
                    StravaData.pace = metricsAvailability.pace ? formatPace(parsedData.moving_time, parsedData.distance) + ' /km' : null;
                    StravaData.elevationGain = metricsAvailability.elevationGain ? Math.round(parsedData.total_elevation_gain) + 'm' : null;
                    StravaData.avgHeartRate = metricsAvailability.avgHeartRate ? Math.round(parsedData.average_heartrate) + ' bpm' : null;
                    StravaData.maxHeartRate = metricsAvailability.maxHeartRate ? Math.round(parsedData.max_heartrate) + ' bpm' : null;
                    StravaData.calories = metricsAvailability.calories ? Math.round(parsedData.calories) : null;
                    StravaData.sufferScore = metricsAvailability.sufferScore ? Math.round(parsedData.suffer_score) : null;

                    // --- Apply Button Styles Based on Availability and Default Selection ---
                    document.querySelectorAll('.overlay-option').forEach(button => {
                        const metric = button.dataset.metric;

                        // Reset classes and disabled state
                        button.classList.remove('bg-strava-orange', 'bg-strava-gray', 'bg-gray-300', 'cursor-not-allowed');
                        button.disabled = false;

                        if (!metricsAvailability[metric]) {
                            // State 1: Unavailable Metric -> Darker Grey, Disabled
                            button.disabled = true;
                            button.classList.add('bg-gray-300', 'cursor-not-allowed');
                        } else {
                            // Metric is Available
                            if (state.selectedMetrics.includes(metric)) {
                                // State 2: Available AND Selected (including defaults) -> Strava Orange, Enabled
                                button.classList.add('bg-strava-orange');
                            } else {
                                // State 3: Available BUT Not Selected -> Strava Grey, Enabled
                                button.classList.add('bg-strava-gray');
                            }
                        }
                    });

                    generateOverlay();

                    // console.log(`Activity "${parsedData.name || 'Untitled Activity'}" loaded from session storage.`);

                } catch (error) {
                    console.error('Error parsing activity data from sessionStorage:', error);
                    console.log("Corrupted data found:", storedActivity); // Log the problematic data
                    // Clear corrupted data and redirect
                    sessionStorage.removeItem('currentActivity');
                    alert('Error loading activity data from storage. Please load the activity again.');
                }
            }

            function formatDuration(seconds) {
                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                const remainingSeconds = seconds % 60;
                
                if (hours > 0) {
                    return `${hours}h ${minutes}m ${remainingSeconds}s`;
                }
                return `${minutes}m ${remainingSeconds}s`;
            }

            function formatPace(seconds, distance) {
                if (!distance) return "0:00";
                const paceInSeconds = seconds / (distance / 1000);
                const minutes = Math.floor(paceInSeconds / 60);
                const remainingSeconds = Math.ceil(paceInSeconds % 60);
                return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
            }

            // --- Canvas Drawing Logic (Moved outside DOMContentLoaded for clarity) ---

            const canvas = document.getElementById('overlayCanvas');
            const ctx = canvas.getContext('2d');
            const colorWheel = document.getElementById('colorWheel');
            const copyTextBtn = document.getElementById('copyTextBtn');
            const copyImageBtn = document.getElementById('copyImageBtn');
            const toast = document.getElementById('toast');

            let currentTextColor = '#ffffff'; // Default text color (white, as per color wheel initial value)

            // --- Constants for Drawing ---
            const BASE_FONT_SIZE = 30; // Base size similar to old file adjusted for 9:16
            const VALUE_FONT_SIZE_MULTIPLIER = 1.33; // Value slightly larger than title
            const MIN_FONT_SIZE = 10; // Minimum font size to prevent text becoming too small
            const VERTICAL_PADDING_FACTOR = 0.9; // Use 90% of canvas height
            const ITEM_SPACING = 15; // Spacing between metric blocks (label+value)
            const TEXT_PADDING = 20; // Padding for left/right aligned text

            function resizeCanvas() {
                const container = canvas.parentElement;
                const dpr = window.devicePixelRatio || 1;
                
                // Get the container's computed dimensions
                const rect = container.getBoundingClientRect();
                
                // Set canvas size in pixels, accounting for DPR
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
                
                // Scale all drawing operations by DPR
                ctx.scale(dpr, dpr);
                
                // Set display size (CSS pixels)
                canvas.style.width = `${rect.width}px`;
                canvas.style.height = `${rect.height}px`;
                
                generateOverlay();
            }

            function drawMetrics(data, context = ctx) {
                const metrics = state.selectedMetrics
                    .map(key => ({
                        name: getMetricLabel(key),
                        value: data[key]
                    }))
                    .filter(metric => metric.value !== null && metric.value !== undefined);

                if (metrics.length === 0) return;

                const dpr = window.devicePixelRatio || 1;
                
                // Use logical (CSS) pixels for calculations
                const logicalWidth = overlayCanvas.width / dpr;
                const logicalHeight = overlayCanvas.height / dpr;

                // Set up text alignment and position
                context.textAlign = state.textAlign;
                context.textBaseline = 'middle';
                context.fillStyle = state.textColor;

                // Calculate dynamic font sizes (based on canvas height)
                const baseFontSize = Math.min(logicalHeight * 0.07, 40); // Cap maximum size
                let titleFontSize = baseFontSize;
                let valueFontSize = baseFontSize * 1.2;
                let spacing = baseFontSize * 0.8;

                // Calculate metrics block total height
                const getBlockHeight = () => {
                    return metrics.length * (titleFontSize + valueFontSize + spacing);
                };

                // Scale down fonts if content is too tall or wide
                while (getBlockHeight() > logicalHeight * 0.8) {
                    titleFontSize *= 0.95;
                    valueFontSize *= 0.95;
                    spacing *= 0.95;

                    // Prevent infinite loop with minimum size
                    if (titleFontSize < 12) break;
                }

                // Center the entire block vertically
                const totalHeight = getBlockHeight();
                let currentY = (logicalHeight - totalHeight) / 2;

                // Calculate x position based on alignment
                const xPos = state.textAlign === 'left' ? 
                            TEXT_PADDING : 
                            state.textAlign === 'right' ? 
                            logicalWidth - TEXT_PADDING : 
                            logicalWidth / 2;

                // Draw each metric with adjusted x position
                metrics.forEach(metric => {
                    // Title
                    context.font = `${titleFontSize}px Roboto`;
                    context.fillText(metric.name, xPos, currentY + titleFontSize/2);

                    // Value
                    context.font = `bold ${valueFontSize}px Roboto`;
                    context.fillText(
                        metric.value, 
                        xPos, 
                        currentY + titleFontSize + spacing/2 + valueFontSize/2
                    );

                    currentY += titleFontSize + valueFontSize + spacing;
                });
            }

            // Existing code
            document.querySelectorAll('.overlay-option').forEach(option => {
                option.addEventListener('click', () => {
                    const metric = option.dataset.metric;
                    
                    if (option.classList.contains('bg-strava-orange')) {
                        option.classList.remove('bg-strava-orange');
                        option.classList.add('bg-strava-gray');
                        state.selectedMetrics = state.selectedMetrics.filter(m => m !== metric);
                    } else {
                        option.classList.remove('bg-strava-gray');
                        option.classList.add('bg-strava-orange');
                        state.selectedMetrics.push(metric);
                    }

                    generateOverlay(StravaData);
                });
            });

            // Generate Overlay
            function generateOverlay(data = StravaData) {
                // Clear the entire canvas
                ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

                // Add dark checkerboard class to canvas
                canvas.classList.add('dark-checkerboard');

                // Draw metrics
                drawMetrics(data);
            }

            // --- Ported getCroppedDimensions from old file, adapted for new drawing logic ---
            function getCroppedDimensions(data, context, canvasRef) {
                if (!canvasRef) return { x: 0, y: 0, width: 0, height: 0 }; // Handle missing canvas

                const metrics = state.selectedMetrics
                    .map(key => ({
                        name: getMetricLabel(key),
                        value: data[key]
                    }))
                    .filter(metric => metric.value !== null && metric.value !== undefined);

                if (metrics.length === 0) return { x: 0, y: 0, width: canvasRef.width, height: canvasRef.height }; // Return full canvas if empty

                const dpr = window.devicePixelRatio || 1;
                const canvasWidthLogical = canvasRef.width / dpr;
                const canvasHeightLogical = canvasRef.height / dpr;
                const maxHeightLogical = canvasHeightLogical * VERTICAL_PADDING_FACTOR;
                const centerXLogical = canvasWidthLogical / 2;
                const centerYLogical = canvasHeightLogical / 2;

                // Recalculate font sizes exactly as in drawMetrics
                let titleFontSize = BASE_FONT_SIZE;
                let valueFontSize = BASE_FONT_SIZE * VALUE_FONT_SIZE_MULTIPLIER;
                let spacing = ITEM_SPACING;
                let totalHeightLogical;
                do {
                    const itemHeight = titleFontSize + valueFontSize + 5;
                    const totalSpacing = (metrics.length - 1) * spacing;
                    totalHeightLogical = (metrics.length * itemHeight) + totalSpacing;
                    if (totalHeightLogical > maxHeightLogical && titleFontSize > MIN_FONT_SIZE) {
                        titleFontSize *= 0.95;
                        valueFontSize *= 0.95;
                        spacing *= 0.95;
                    } else {
                        break;
                    }
                } while (true);

                // Calculate content bounds (in physical pixels)
                const contentHeightPhysical = totalHeightLogical * dpr;
                const startYPhysical = (centerYLogical - (totalHeightLogical / 2)) * dpr;
                const endYPhysical = startYPhysical + contentHeightPhysical;

                // Calculate horizontal bounds based on the actual font sizes used (physical pixels)
                let maxTextWidthPhysical = 0;
                context.textAlign = 'center'; // Ensure context is set correctly for measurement
                metrics.forEach(metric => {
                    context.font = `normal ${titleFontSize * dpr}px Roboto`;
                    const titleWidth = context.measureText(metric.name).width;
                    context.font = `bold ${valueFontSize * dpr}px Roboto`;
                    const valueWidth = context.measureText(metric.value).width;
                    maxTextWidthPhysical = Math.max(maxTextWidthPhysical, titleWidth, valueWidth);
                });

                const centerXPhysical = canvasRef.width / 2;
                const contentStartXPhysical = centerXPhysical - (maxTextWidthPhysical / 2);
                // const contentEndXPhysical = centerXPhysical + (maxTextWidthPhysical / 2); // Not needed directly

                const marginPhysical = 20 * dpr; // Margin in physical pixels

                // Return dimensions in physical pixels, clamped to canvas bounds
                const finalX = Math.max(0, contentStartXPhysical - marginPhysical);
                const finalY = Math.max(0, startYPhysical - marginPhysical);
                const finalWidth = Math.min(canvasRef.width - finalX, maxTextWidthPhysical + (2 * marginPhysical));
                const finalHeight = Math.min(canvasRef.height - finalY, contentHeightPhysical + (2 * marginPhysical));

                 return {
                    x: finalX,
                    y: finalY,
                    width: finalWidth,
                    height: finalHeight
                };
            }

            function getCroppedDimensions(data, context, canvasRef) {
                if (!canvasRef) return { x: 0, y: 0, width: 0, height: 0 };
                
                const metrics = state.selectedMetrics
                    .map(key => ({
                        name: getMetricLabel(key),
                        value: data[key]
                    }))
                    .filter(metric => metric.value !== null && metric.value !== undefined);

                if (metrics.length === 0) return { x: 0, y: 0, width: canvasRef.width, height: canvasRef.height };

                const dpr = window.devicePixelRatio || 1;
                const canvasWidthLogical = canvasRef.width / dpr;
                const canvasHeightLogical = canvasRef.height / dpr;

                // Calculate font sizes just like in drawMetrics
                const baseFontSize = Math.min(canvasHeightLogical * 0.07, 40);
                let titleFontSize = baseFontSize;
                let valueFontSize = baseFontSize * 1.2;
                let spacing = baseFontSize * 0.8;

                // Find the widest text
                context.textAlign = 'center'; // Temporarily set to center for measurement
                let maxWidth = 0;
                metrics.forEach(metric => {
                    context.font = `${titleFontSize * dpr}px Roboto`;
                    const titleWidth = context.measureText(metric.name).width;
                    context.font = `bold ${valueFontSize * dpr}px Roboto`;
                    const valueWidth = context.measureText(metric.value).width;
                    maxWidth = Math.max(maxWidth, titleWidth, valueWidth);
                });

                // Calculate content height
                const totalHeight = metrics.length * (titleFontSize + valueFontSize + spacing) * dpr;
                const padding = TEXT_PADDING * dpr;
                
                // Calculate crop box position based on alignment
                let x, width;
                if (state.textAlign === 'left') {
                    x = padding;
                    width = maxWidth + padding * 2;
                } else if (state.textAlign === 'right') {
                    x = canvasRef.width - maxWidth - padding * 2;
                    width = maxWidth + padding * 2;
                } else {
                    // center alignment
                    x = (canvasRef.width - maxWidth) / 2 - padding;
                    width = maxWidth + padding * 2;
                }

                // Vertical centering remains the same
                const y = (canvasRef.height - totalHeight) / 2 - padding;
                const height = totalHeight + padding * 2;

                return {
                    x: Math.max(0, x),
                    y: Math.max(0, y),
                    width: Math.min(canvasRef.width - x, width),
                    height: Math.min(canvasRef.height - y, height)
                };
            }

            // --- End Ported getCroppedDimensions ---

            function getMetricLabel(metricKey) {
                const labels = {
                    distance: 'Distance',
                    movingTime: 'Time',
                    pace: 'Pace',
                    elevationGain: 'Elevation',
                    avgHeartRate: 'Avg HR',
                    maxHeartRate: 'Max HR',
                    calories: 'Calories',
                    sufferScore: 'Suffer Score'
                };
                return labels[metricKey] || metricKey; // Fallback to key if no label found
            }

            function showToast(message) {
                toast.textContent = message;
                toast.classList.remove('opacity-0');
                setTimeout(() => {
                    toast.classList.add('opacity-0');
                }, 2000);
            }

            // Update color wheel handler
            colorWheel.addEventListener('input', (e) => {
                if (!state.isAuthenticated) {
                    showStatusMessage('Please login to customize colors', 'warning');
                    return;
                }
                if (!state.activityId) {
                    showStatusMessage('Please load an activity first to customize colors', 'warning');
                    return;
                }

                state.textColor = e.target.value;
                generateOverlay(StravaData);
            });

                // Copy Text Button - Seems mostly correct, ensure toast
                copyTextBtn?.addEventListener('click', () => {
                    if (!state.activityData || state.selectedMetrics.length === 0) return;

                    const textToCopy = state.selectedMetrics
                        .map(metric => {
                            const value = StravaData[metric];
                            return value !== null && value !== undefined 
                                ? `${getMetricLabel(metric)}\n${value}`  // Put label and value on separate lines
                                : null;
                        })
                        .filter(line => line !== null)
                        .join('\n\n');  // Add double line break between metrics

                    if (textToCopy) {
                        navigator.clipboard.writeText(textToCopy)
                            .then(() => showToast('Text copied!'))
                            .catch(err => {
                                console.error('Failed to copy text: ', err);
                                showToast('Failed to copy text');
                            });
                    }
                });

                // Copy Image Button - Replace with ported logic
                copyImageBtn?.addEventListener('click', async () => {
                    if (!state.activityData || state.selectedMetrics.length === 0) {
                        console.warn('No activity data or selected metrics to copy.');
                        return;
                    }
                    if (!canvas) {
                        console.error("Canvas element not found for copying image.");
                        return;
                    }
                    const checkerboard = canvas.previousElementSibling; // Get the checkerboard div

                    try {
                        // Temporarily hide the checkerboard background for copying
                        if (checkerboard && checkerboard.classList.contains('checkerboard')) {
                           checkerboard.style.opacity = '0'; // Hide instead of display none to avoid layout shifts
                        }

                        // Ensure canvas is fully rendered - small delay might help
                        // await new Promise(resolve => setTimeout(resolve, 100)); // Increased delay slightly

                        // Get dimensions of the drawn content
                        const bbox = getCroppedDimensions(StravaData, ctx, canvas);

                        if (!bbox || bbox.width <= 0 || bbox.height <= 0) {
                            console.warn("No content detected on canvas or invalid bounding box.", bbox);
                             if (checkerboard) checkerboard.style.opacity = ''; // Restore background
                            showToast('Nothing to copy');
                            return;
                        }

                        // Create a temporary canvas sized to the bounding box
                        const tempCanvas = document.createElement('canvas');
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCanvas.width = bbox.width;
                        tempCanvas.height = bbox.height;                    

                        // Draw the relevant part of the original canvas onto the temporary canvas
                        // Source rect: bbox.x, bbox.y, bbox.width, bbox.height
                        // Dest rect: 0, 0, bbox.width, bbox.height
                        tempCtx.drawImage(
                            canvas,
                            bbox.x, bbox.y, bbox.width, bbox.height, // Source rectangle (from original canvas)
                            0, 0, bbox.width, bbox.height           // Destination rectangle (whole temp canvas)
                        );


                        // Convert temp canvas to Blob for clipboard API
                        tempCanvas.toBlob(async (blob) => {
                            if (!blob) {
                                throw new Error("Canvas toBlob failed");
                            }
                            try {
                                // Use ClipboardItem API
                                await navigator.clipboard.write([
                                    new ClipboardItem({ 'image/png': blob })
                                ]);
                                showToast('Image copied!');
                            } catch (err) {
                                console.error('Failed to copy image using ClipboardItem API: ', err);
                                showToast('Failed to copy image');
                                // Consider a fallback download here if needed
                            } finally {
                                // Restore checkerboard visibility regardless of success/failure
                                if (checkerboard) checkerboard.style.opacity = '';
                            }
                        }, 'image/png');

                    } catch (err) {
                        console.error('Error preparing image for copy: ', err);
                        showToast('Error copying image');
                        // Ensure checkerboard is restored in case of error
                        if (checkerboard) checkerboard.style.opacity = '';
                    }
                });

                // Initial canvas setup and resize listener
                if (canvas) {
                    resizeCanvas(); // Initial size
                    window.addEventListener('resize', resizeCanvas);
                }

            // Move this inside DOMContentLoaded, after state is defined
            document.querySelectorAll('.text-align-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const alignment = btn.dataset.align;
                    
                    // Update buttons
                    document.querySelectorAll('.text-align-btn').forEach(b => {
                        b.classList.toggle('active', b === btn);
                    });
                    
                    // Update state and redraw
                    state.textAlign = alignment;
                    generateOverlay(StravaData);
                });
            });

            const sections = {
                text: document.getElementById('textSection'),
                maps: document.getElementById('mapsSection'),
                graphs: document.getElementById('graphsSection')
            };

            // Add these event listeners after your existing ones
            document.querySelectorAll('.section-header').forEach(header => {
                header.addEventListener('click', () => {
                    const sectionName = header.dataset.section;
                    
                    // Toggle active state on headers
                    document.querySelectorAll('.section-header').forEach(h => {
                        h.classList.toggle('bg-gray-200', h === header);
                        h.classList.toggle('bg-gray-100', h !== header);
                    });
                    
                    // Toggle sections
                    Object.entries(sections).forEach(([name, element]) => {
                        element.classList.toggle('hidden', name !== sectionName);
                    });
                });
            });

            // Add initial active state for text section
            document.querySelector('[data-section="text"]').classList.add('bg-gray-200');
            document.querySelector('[data-section="text"]').classList.remove('bg-gray-100');

            // Add map style button handlers
            document.querySelectorAll('.map-option').forEach(button => {
                button.addEventListener('click', () => {
                    const style = button.dataset.style;
                    console.log(`Map style selected: ${style}`);
                    
                    // Remove active state from all map buttons
                    document.querySelectorAll('.map-option').forEach(btn => {
                        btn.classList.remove('bg-strava-orange');
                        btn.classList.add('bg-strava-gray');
                    });
                    
                    // Add active state to clicked button
                    button.classList.remove('bg-strava-gray');
                    button.classList.add('bg-strava-orange');
                });
            });

            // Add graph button handlers
            document.querySelectorAll('.graph-option').forEach(button => {
                button.addEventListener('click', () => {
                    const graphType = button.dataset.graph;
                    console.log(`Graph type selected: ${graphType}`);
                    
                    // Remove active state from all graph buttons
                    document.querySelectorAll('.graph-option').forEach(btn => {
                        btn.classList.remove('bg-strava-orange');
                        btn.classList.add('bg-strava-gray');
                    });
                    
                    // Add active state to clicked button
                    button.classList.remove('bg-strava-gray');
                    button.classList.add('bg-strava-orange');
                });
            });

            // Add after your existing event listeners
            document.querySelectorAll('.text-align-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const alignment = btn.dataset.align;
                    
                    // Update buttons
                    document.querySelectorAll('.text-align-btn').forEach(b => {
                        b.classList.toggle('active', b === btn);
                    });
                    
                    // Update state and redraw
                    state.textAlign = alignment;
                    generateOverlay(StravaData);
                });
            });
        });
    </script>
</body>
</html>